/**
 * SubscriberManagementAPI
 * The SubscriberManagementAPI, part of ViewBid.ca Auction application provides functionalities to manage subscriber data.  Specifically, it supports creating, updating, retrieving, and deleting subscriber records through standard CRUD operations. Additionally, it offers specialized example methods for administrative tasks such as calculating the number of active (\"good\") subscribers and automated cleanup of inactive subscriber accounts (unused for 60 days or more). 
 *
 * The version of the OpenAPI document: 25.03.21d
 * Contact: willdev@viewbid.ca
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Injectable, Optional } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import type { AxiosRequestConfig, AxiosResponse } from 'axios';
import { Observable, from, of, switchMap } from 'rxjs';
import { Subscribers } from '../model/subscribers';
import { Configuration } from '../configuration';
import { COLLECTION_FORMATS } from '../variables';


@Injectable()
export class SubscribersService {

    protected basePath = 'http://localhost';
    public defaultHeaders: Record<string,string> = {};
    public configuration = new Configuration();
    protected httpClient: HttpService;

    constructor(httpClient: HttpService, @Optional() configuration: Configuration) {
        this.configuration = configuration || this.configuration;
        this.basePath = configuration?.basePath || this.basePath;
        this.httpClient = configuration?.httpClient || httpClient;
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        return consumes.includes(form);
    }

    /**
     * Creates a new subscribers record.
     * 
     * @param subscribers 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [createsubscribersOpts.config] Override http request option.
     */
    public createsubscribers(subscribers: Subscribers, createsubscribersOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<Subscribers>>;
    public createsubscribers(subscribers: Subscribers, createsubscribersOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (subscribers === null || subscribers === undefined) {
            throw new Error('Required parameter subscribers was null or undefined when calling createsubscribers.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<Subscribers>(`${this.basePath}/subscribers`,
                    subscribers,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...createsubscribersOpts?.config,
                        headers: {...headers, ...createsubscribersOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Deletes an existing subscribers record based on the provided ID.
     * 
     * @param id TODO
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [deletesubscribersOpts.config] Override http request option.
     */
    public deletesubscribers(id: string, deletesubscribersOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<Subscribers>>;
    public deletesubscribers(id: string, deletesubscribersOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deletesubscribers.');
        }

        let queryParameters = new URLSearchParams();
        if (id !== undefined && id !== null) {
            queryParameters.append('id', <any>id);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<Subscribers>(`${this.basePath}/subscribers`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...deletesubscribersOpts?.config,
                        headers: {...headers, ...deletesubscribersOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Retrieves a list of all subscribers
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [listsubscribersOpts.config] Override http request option.
     */
    public listsubscribers(listsubscribersOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<Subscribers>>;
    public listsubscribers(listsubscribersOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<Subscribers>(`${this.basePath}/subscribers`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...listsubscribersOpts?.config,
                        headers: {...headers, ...listsubscribersOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Updates an existing subscribers record.
     * 
     * @param subscribers 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [patchsubscribersOpts.config] Override http request option.
     */
    public patchsubscribers(subscribers: Subscribers, patchsubscribersOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<Subscribers>>;
    public patchsubscribers(subscribers: Subscribers, patchsubscribersOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (subscribers === null || subscribers === undefined) {
            throw new Error('Required parameter subscribers was null or undefined when calling patchsubscribers.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.patch<Subscribers>(`${this.basePath}/subscribers`,
                    subscribers,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...patchsubscribersOpts?.config,
                        headers: {...headers, ...patchsubscribersOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * retrieve an existing subscribers record based on the provided ID.
     * 
     * @param id TODO
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [retreivesubscribersOpts.config] Override http request option.
     */
    public retreivesubscribers(id: string, retreivesubscribersOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<Subscribers>>;
    public retreivesubscribers(id: string, retreivesubscribersOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling retreivesubscribers.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<Subscribers>(`${this.basePath}/subscribers/${encodeURIComponent(String(id))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...retreivesubscribersOpts?.config,
                        headers: {...headers, ...retreivesubscribersOpts?.config?.headers},
                    }
                );
            })
        );
    }
}
